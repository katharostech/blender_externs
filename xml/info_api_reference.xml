<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.14 -->
<document source="/home/zicklag/git/other/blender/doc/python_api/sphinx-in/info_api_reference.rst">
    <section ids="reference-api-usage" names="reference\ api\ usage">
        <title>Reference API Usage</title>
        <paragraph>Blender has many interlinking data types which have an auto-generated reference api which often has the information
            you need to write a script, but can be difficult to use.</paragraph>
        <paragraph>This document is designed to help you understand how to use the reference api.</paragraph>
        <section ids="reference-api-scope" names="reference\ api\ scope">
            <title>Reference API Scope</title>
            <paragraph>The reference API covers <reference internal="True" reftitle="bpy.types" refuri="bpy.types.wmTools#module-bpy.types"><literal classes="xref py py-mod">bpy.types</literal></reference>, which stores types accessed via <reference internal="True" reftitle="bpy.context" refuri="bpy.context#module-bpy.context"><literal classes="xref py py-mod">bpy.context</literal></reference> - <emphasis>The user context</emphasis>
                or <reference internal="True" reftitle="bpy.data" refuri="bpy.data#bpy.data"><literal classes="xref py py-mod">bpy.data</literal></reference> - <emphasis>Blend file data</emphasis>.</paragraph>
            <paragraph>Other modules such as <reference internal="True" reftitle="bmesh" refuri="bmesh#module-bmesh"><literal classes="xref py py-mod">bmesh</literal></reference> and <reference internal="True" reftitle="aud" refuri="aud#module-aud"><literal classes="xref py py-mod">aud</literal></reference> are not using Blenders data API
                so this document doesn’t apply to those modules.</paragraph>
        </section>
        <section ids="data-access" names="data\ access">
            <title>Data Access</title>
            <paragraph>The most common case for using the reference API is to find out how to access data in the blend file.</paragraph>
            <paragraph>Before going any further its best to be aware of ID Data-Blocks in Blender since you will often find properties
                relative to them.</paragraph>
            <section ids="id-data" names="id\ data">
                <title>ID Data</title>
                <paragraph>ID Data-Blocks are used in Blender as top-level data containers.</paragraph>
                <paragraph>From the user interface this isn’t so obvious, but when developing you need to know about ID Data-Blocks.</paragraph>
                <paragraph>ID data types include Scene, Group, Object, Mesh, Screen, World, Armature, Image and Texture.
                    for a full list see the sub-classes of <reference internal="True" reftitle="bpy.types.ID" refuri="bpy.types.ID#bpy.types.ID"><literal classes="xref py py-class">bpy.types.ID</literal></reference></paragraph>
                <paragraph>Here are some characteristics ID Data-Blocks share.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>ID’s are blend file data, so loading a new blend file reloads an entire new set of Data-Blocks.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>ID’s can be accessed in Python from <literal>bpy.data.*</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Each data-block has a unique <literal>.name</literal> attribute, displayed in the interface.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Animation data is stored in ID’s <literal>.animation_data</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>ID’s are the only data types that can be linked between blend files.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>ID’s can be added/copied and removed via Python.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>ID’s have their own garbage-collection system which frees unused ID’s when saving.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>When a data-block has a reference to some external data, this is typically an ID Data-Block.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="simple-data-access" names="simple\ data\ access">
                <title>Simple Data Access</title>
                <paragraph>Lets start with a simple case, say you want a python script to adjust the object’s location.</paragraph>
                <paragraph>Start by finding this setting in the interface <literal>Properties Window -&gt; Object -&gt; Transform -&gt; Location</literal></paragraph>
                <paragraph>From the button you can right click and select <strong>Online Python Reference</strong>, this will link you to:
                    <reference internal="True" reftitle="bpy.types.Object.location" refuri="bpy.types.Object#bpy.types.Object.location"><literal classes="xref py py-class">bpy.types.Object.location</literal></reference></paragraph>
                <paragraph>Being an API reference, this link often gives little more information then the tool-tip, though some of the pages
                    include examples (normally at the top of the page).</paragraph>
                <paragraph>At this point you may say <emphasis>Now what?</emphasis> - you know that you have to use <literal>.location</literal> and that its an array of 3 floats
                    but you’re still left wondering how to access this in a script.</paragraph>
                <paragraph>So the next step is to find out where to access objects, go down to the bottom of the page to the <strong>References</strong>
                    section, for objects there are many references, but one of the most common places to access objects is via the context.</paragraph>
                <paragraph>It’s easy to be overwhelmed at this point since there <literal>Object</literal> get referenced in so many places - modifiers,
                    functions, textures and constraints.</paragraph>
                <paragraph>But if you want to access any data the user has selected
                    you typically only need to check the <reference internal="True" reftitle="bpy.context" refuri="bpy.context#module-bpy.context"><literal classes="xref py py-mod">bpy.context</literal></reference> references.</paragraph>
                <paragraph>Even then, in this case there are quite a few though if you read over these - most are mode specific.
                    If you happen to be writing a tool that only runs in weight paint mode, then using <literal>weight_paint_object</literal>
                    would be appropriate.
                    However to access an item the user last selected, look for the <literal>active</literal> members,
                    Having access to a single active member the user selects is a convention in Blender: eg. <literal>active_bone</literal>,
                    <literal>active_pose_bone</literal>, <literal>active_node</literal> … and in this case we can use - <literal>active_object</literal>.</paragraph>
                <paragraph>So now we have enough information to find the location of the active object.</paragraph>
                <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.context.active_object.location</literal_block>
                <paragraph>You can type this into the python console to see the result.</paragraph>
                <paragraph>The other common place to access objects in the reference is <reference internal="True" reftitle="bpy.types.BlendData.objects" refuri="bpy.types.BlendData#bpy.types.BlendData.objects"><literal classes="xref py py-class">bpy.types.BlendData.objects</literal></reference>.</paragraph>
                <note>
                    <paragraph>This is <strong>not</strong> listed as <literal classes="xref py py-mod">bpy.data.objects</literal>,
                        this is because <reference internal="True" reftitle="bpy.data" refuri="bpy.data#bpy.data"><literal classes="xref py py-mod">bpy.data</literal></reference> is an instance of the <reference internal="True" reftitle="bpy.types.BlendData" refuri="bpy.types.BlendData#bpy.types.BlendData"><literal classes="xref py py-class">bpy.types.BlendData</literal></reference> class,
                        so the documentation points there.</paragraph>
                </note>
                <paragraph>With <literal classes="xref py py-mod">bpy.data.objects</literal>, this is a collection of objects so you need to access one of its members.</paragraph>
                <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.data.objects["Cube"].location</literal_block>
            </section>
            <section ids="nested-properties" names="nested\ properties">
                <title>Nested Properties</title>
                <paragraph>The previous example is quite straightforward because <literal>location</literal> is a property of <literal>Object</literal> which can be accessed
                    from the context directly.</paragraph>
                <paragraph>Here are some more complex examples:</paragraph>
                <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># access a render layers samples
bpy.context.scene.render.layers["RenderLayer"].samples

# access to the current weight paint brush size
bpy.context.tool_settings.weight_paint.brush.size

# check if the window is fullscreen
bpy.context.window.screen.show_fullscreen</literal_block>
                <paragraph>As you can see there are times when you want to access data which is nested
                    in a way that causes you to go through a few indirections.</paragraph>
                <paragraph>The properties are arranged to match how data is stored internally (in blenders C code) which is often logical but
                    not always quite what you would expect from using Blender.</paragraph>
                <paragraph>So this takes some time to learn, it helps you understand how data fits together in Blender which is important
                    to know when writing scripts.</paragraph>
                <paragraph>When starting out scripting you will often run into the problem where you’re not sure how to access the data you want.</paragraph>
                <paragraph>There are a few ways to do this.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Use the Python console’s auto-complete to inspect properties.
                            <emphasis>This can be hit-and-miss but has the advantage
                                that you can easily see the values of properties and assign them to interactively see the results.</emphasis></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Copy the Data-Path from the user interface.
                            <emphasis>Explained further in :ref:`Copy Data Path &lt;info_data_path_copy&gt;`</emphasis></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Using the documentation to follow references.
                            <emphasis>Explained further in :ref:`Indirect Data Access &lt;info_data_path_indirect&gt;`</emphasis></paragraph>
                    </list_item>
                </bullet_list>
                <target refid="info-data-path-copy"></target>
            </section>
            <section ids="copy-data-path info-data-path-copy" names="copy\ data\ path info_data_path_copy">
                <title>Copy Data Path</title>
                <paragraph>Blender can compute the Python string to a property which is shown in the tool-tip, on the line below <literal>Python: ...</literal>,
                    This saves having to use the API reference to click back up the references to find where data is accessed from.</paragraph>
                <paragraph>There is a user-interface feature to copy the data-path which gives the path from an <reference internal="True" reftitle="bpy.types.ID" refuri="bpy.types.ID#bpy.types.ID"><literal classes="xref py py-class">bpy.types.ID</literal></reference> data-block,
                    to its property.</paragraph>
                <paragraph>To see how this works we’ll get the path to the Subdivision-Surface modifiers subdivision setting.</paragraph>
                <paragraph>Start with the default scene and select the <strong>Modifiers</strong> tab, then add a <strong>Subdivision-Surface</strong> modifier to the cube.</paragraph>
                <paragraph>Now hover your mouse over the button labeled <strong>View</strong>, The tool-tip includes <reference internal="True" reftitle="bpy.types.SubsurfModifier.levels" refuri="bpy.types.SubsurfModifier#bpy.types.SubsurfModifier.levels"><literal classes="xref py py-class">bpy.types.SubsurfModifier.levels</literal></reference>
                    but we want the path from the object to this property.</paragraph>
                <paragraph>Note that the text copied won’t include the <literal>bpy.data.collection["name"].</literal> component since its assumed that
                    you won’t be doing collection look-ups on every access and typically you’ll want to use the context rather
                    then access each <reference internal="True" reftitle="bpy.types.ID" refuri="bpy.types.ID#bpy.types.ID"><literal classes="xref py py-class">bpy.types.ID</literal></reference> instance by name.</paragraph>
                <paragraph>Type in the ID path into a Python console <reference internal="True" reftitle="bpy.context.active_object" refuri="bpy.context#bpy.context.active_object"><literal classes="xref py py-mod">bpy.context.active_object</literal></reference>.
                    Include the trailing dot and don’t hit “enter”, yet.</paragraph>
                <paragraph>Now right-click on the button and select <strong>Copy Data Path</strong>, then paste the result into the console.</paragraph>
                <paragraph>So now you should have the answer:</paragraph>
                <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.context.active_object.modifiers["Subsurf"].levels</literal_block>
                <paragraph>Hit “enter” and you’ll get the current value of 1. Now try changing the value to 2:</paragraph>
                <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.context.active_object.modifiers["Subsurf"].levels = 2</literal_block>
                <paragraph>You can see the value update in the Subdivision-Surface modifier’s UI as well as the cube.</paragraph>
                <target refid="info-data-path-indirect"></target>
            </section>
            <section ids="indirect-data-access info-data-path-indirect" names="indirect\ data\ access info_data_path_indirect">
                <title>Indirect Data Access</title>
                <paragraph>For this example we’ll go over something more involved, showing the steps to access the active sculpt brushes texture.</paragraph>
                <paragraph>Lets say we want to access the texture of a brush via Python, to adjust its <literal>contrast</literal> for example.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Start in the default scene and enable ‘Sculpt’ mode from the 3D-View header.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>From the toolbar expand the <strong>Texture</strong> panel and add a new texture.
                            <emphasis>Notice the texture button its self doesn’t have very useful links (you can check the tooltips).</emphasis></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The contrast setting isn’t exposed in the sculpt toolbar, so view the texture in the properties panel…</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>In the properties button select the Texture context.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Select the Brush icon to show the brush texture.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Expand the <emphasis>Colors</emphasis> panel to locate the <emphasis>Contrast</emphasis> button.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph>Right click on the contrast button and select <strong>Online Python Reference</strong>
                            This takes you to <literal>bpy.types.Texture.contrast</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Now we can see that <literal>contrast</literal> is a property of texture,
                            so next we’ll check on how to access the texture from the brush.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Check on the <strong>References</strong> at the bottom of the page, sometimes there are many references, and it may take
                            some guess work to find the right one, but in this case its obviously <literal>Brush.texture</literal>.</paragraph>
                        <paragraph><emphasis>Now we know that the texture can be accessed from</emphasis> <literal>bpy.data.brushes["BrushName"].texture</literal>
                            <emphasis>but normally you won’t want to access the brush by name, so we’ll see now to access the active brush instead.</emphasis></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>So the next step is to check on where brushes are accessed from via the <strong>References</strong>.
                            In this case there is simply <literal>bpy.context.brush</literal> which is all we need.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Now you can use the Python console to form the nested properties needed to access brush textures contrast,
                    logically we now know.</paragraph>
                <paragraph><emphasis>Context -&gt; Brush -&gt; Texture -&gt; Contrast</emphasis></paragraph>
                <paragraph>Since the attribute for each is given along the way we can compose the data path in the python console:</paragraph>
                <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.context.brush.texture.contrast</literal_block>
                <paragraph>There can be multiple ways to access the same data, which you choose often depends on the task.</paragraph>
                <paragraph>An alternate path to access the same setting is…</paragraph>
                <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.context.sculpt.brush.texture.contrast</literal_block>
                <paragraph>Or access the brush directly…</paragraph>
                <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.data.brushes["BrushName"].texture.contrast</literal_block>
                <paragraph>If you are writing a user tool normally you want to use the <reference internal="True" reftitle="bpy.context" refuri="bpy.context#module-bpy.context"><literal classes="xref py py-mod">bpy.context</literal></reference> since the user normally expects
                    the tool to operate on what they have selected.</paragraph>
                <paragraph>For automation you are more likely to use <reference internal="True" reftitle="bpy.data" refuri="bpy.data#bpy.data"><literal classes="xref py py-mod">bpy.data</literal></reference> since you want to be able to access specific data and manipulate
                    it, no matter what the user currently has the view set at.</paragraph>
            </section>
        </section>
        <section ids="operators" names="operators">
            <title>Operators</title>
            <paragraph>Most key-strokes and buttons in Blender call an operator which is also exposed to python via <literal classes="xref py py-mod">bpy.ops</literal>,</paragraph>
            <paragraph>To see the Python equivalent hover your mouse over the button and see the tool-tip,
                eg <literal>Python: bpy.ops.render.render()</literal>,
                If there is no tool-tip or the <literal>Python:</literal> line is missing then this button is not using an operator and
                can’t be accessed from Python.</paragraph>
            <paragraph>If you want to use this in a script you can press <literal classes="kbd">Control-C</literal> while your mouse is over the button to copy it to the
                clipboard.</paragraph>
            <paragraph>You can also right click on the button and view the <strong>Online Python Reference</strong>, this mainly shows arguments and
                their defaults however operators written in Python show their file and line number which may be useful if you
                are interested to check on the source code.</paragraph>
            <note>
                <paragraph>Not all operators can be called usefully from Python,
                    for more on this see <reference internal="True" refuri="info_gotcha#using-operators"><inline classes="std std-ref">using operators</inline></reference>.</paragraph>
            </note>
            <section ids="info-view" names="info\ view">
                <title>Info View</title>
                <paragraph>Blender records operators you run and displays them in the <strong>Info</strong> space.
                    This is located above the file-menu which can be dragged down to display its contents.</paragraph>
                <paragraph>Select the <strong>Script</strong> screen that comes default with Blender to see its output.
                    You can perform some actions and see them show up - delete a vertex for example.</paragraph>
                <paragraph>Each entry can be selected (Right-Mouse-Button),
                    then copied <literal classes="kbd">Control-C</literal>, usually to paste in the text editor or python console.</paragraph>
                <note>
                    <paragraph>Not all operators get registered for display,
                        zooming the view for example isn’t so useful to repeat so its excluded from the output.</paragraph>
                    <paragraph>To display <emphasis>every</emphasis> operator that runs see <reference internal="True" refuri="info_tips_and_tricks#info-show-all-operators"><inline classes="std std-ref">Show All Operators</inline></reference></paragraph>
                </note>
            </section>
        </section>
    </section>
</document>
