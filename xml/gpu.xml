<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.14 -->
<document source="/home/zicklag/git/other/blender/doc/python_api/sphinx-in/gpu.rst">
    <section ids="module-gpu gpu-shader-module-gpu" names="gpu\ shader\ module\ (gpu)">
        <title>GPU Shader Module (gpu)</title>
        <index entries="['single',\ u'gpu\ (module)',\ u'module-gpu',\ '',\ None]"></index>
        <paragraph>This module provides Python wrappers for the GPU implementation in Blender. Some higher level functions can be found in the <title_reference>gpu_extras</title_reference> module.</paragraph>
        <paragraph>Submodules:</paragraph>
        <compound classes="toctree-wrapper">
            <compact_paragraph toctree="True"><bullet_list><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="gpu.types">GPU Types (gpu.types)</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="gpu.shader">GPU Shader (gpu.shader)</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="gpu.matrix">GPU Matrix (gpu.matrix)</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="gpu.select">GPU Select (gpu.select)</reference></compact_paragraph></list_item></bullet_list></compact_paragraph>
        </compound>
        <section ids="geometry-batches" names="geometry\ batches">
            <title>Geometry Batches</title>
            <paragraph>Geometry is drawn in batches.
                A batch contains the necessary data to perform the drawing.
                That includes an obligatory <emphasis>Vertex Buffer</emphasis> and an optional <emphasis>Index Buffer</emphasis>,
                each of which is described in more detail in the following sections.
                A batch also defines a draw type.
                Typical draw types are <title_reference>POINTS</title_reference>, <title_reference>LINES</title_reference> and <title_reference>TRIS</title_reference>.
                The draw type determines how the data will be interpreted and drawn.</paragraph>
        </section>
        <section ids="vertex-buffers" names="vertex\ buffers">
            <title>Vertex Buffers</title>
            <paragraph>A <emphasis>Vertex Buffer Object</emphasis> (VBO) (<reference internal="True" reftitle="gpu.types.GPUVertBuf" refuri="gpu.types#gpu.types.GPUVertBuf"><literal classes="xref py py-class">gpu.types.GPUVertBuf</literal></reference>)
                is an array that contains the vertex attributes needed for drawing using a specific shader.
                Typical vertex attributes are <emphasis>location</emphasis>, <emphasis>normal</emphasis>, <emphasis>color</emphasis>, and <emphasis>uv</emphasis>.
                Every vertex buffer has a <emphasis>Vertex Format</emphasis> (<reference internal="True" reftitle="gpu.types.GPUVertFormat" refuri="gpu.types#gpu.types.GPUVertFormat"><literal classes="xref py py-class">gpu.types.GPUVertFormat</literal></reference>)
                and a length corresponding to the number of vertices in the buffer.
                A vertex format describes the attributes stored per vertex and their types.</paragraph>
            <paragraph>The following code demonstrates the creation of a vertex buffer that contains 6 vertices.
                For each vertex 2 attributes will be stored: The position and the normal.</paragraph>
            <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">import gpu
vertex_positions = [(0, 0, 0), ...]
vertex_normals = [(0, 0, 1), ...]

fmt = gpu.types.GPUVertFormat()
fmt.attr_add(id="pos", comp_type='F32', len=3, fetch_mode='FLOAT')
fmt.attr_add(id="normal", comp_type='F32', len=3, fetch_mode='FLOAT')

vbo = gpu.types.GPUVertBuf(len=6, format=fmt)
vbo.attr_fill(id="pos", data=vertex_positions)
vbo.attr_fill(id="normal", data=vertex_normals)</literal_block>
            <paragraph>This vertex buffer could be used to draw 6 points, 3 separate lines, 5 consecutive lines, 2 separate triangles, …
                E.g. in the case of lines, each two consecutive vertices define a line.
                The type that will actually be drawn is determined when the batch is created later.</paragraph>
        </section>
        <section ids="index-buffers" names="index\ buffers">
            <title>Index Buffers</title>
            <paragraph>Often triangles and lines share one or more vertices.
                With only a vertex buffer one would have to store all attributes for the these vertices multiple times.
                This is very inefficient because in a connected triangle mesh every vertex is used 6 times on average.
                A more efficient approach would be to use an <emphasis>Index Buffer</emphasis> (IBO) (<reference internal="True" reftitle="gpu.types.GPUIndexBuf" refuri="gpu.types#gpu.types.GPUIndexBuf"><literal classes="xref py py-class">gpu.types.GPUIndexBuf</literal></reference>),
                sometimes referred to as <emphasis>Element Buffer</emphasis>.
                An <emphasis>Index Buffer</emphasis> is an array that references vertices based on their index in the vertex buffer.</paragraph>
            <paragraph>For instance, to draw a rectangle composed of two triangles, one could use an index buffer.</paragraph>
            <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">positions = (
    (-1,  1), (1,  1),
    (-1, -1), (1, -1))

indices = ((0, 1, 2), (2, 1, 3))

ibo = gpu.types.GPUIndexBuf(type='TRIS', seq=indices)</literal_block>
            <paragraph>Here the first tuple in <title_reference>indices</title_reference> describes which vertices should be used for the first triangle
                (same for the second tuple).
                Note how the diagonal vertices 1 and 2 are shared between both triangles.</paragraph>
        </section>
        <section ids="shaders" names="shaders">
            <title>Shaders</title>
            <paragraph>A shader is a program that runs on the GPU (written in GLSL in our case).
                There are multiple types of shaders.
                The most important ones are <emphasis>Vertex Shaders</emphasis> and <emphasis>Fragment Shaders</emphasis>.
                Typically multiple shaders are linked together into a <emphasis>Program</emphasis>.
                However, in the Blender Python API the term <emphasis>Shader</emphasis> refers to an OpenGL Program.
                Every <reference internal="True" reftitle="gpu.types.GPUShader" refuri="gpu.types#gpu.types.GPUShader"><literal classes="xref py py-class">gpu.types.GPUShader</literal></reference> consists of a vertex shader, a fragment shader and an optional geometry shader.
                For common drawing tasks there are some built-in shaders accessible from <reference internal="True" reftitle="gpu.shader.from_builtin" refuri="gpu.shader#gpu.shader.from_builtin"><literal classes="xref py py-class">gpu.shader.from_builtin</literal></reference>
                with an identifier such as <title_reference>2D_UNIFORM_COLOR</title_reference> or <title_reference>3D_FLAT_COLOR</title_reference>.</paragraph>
            <paragraph>Every shader defines a set of attributes and uniforms that have to be set in order to use the shader.
                Attributes are properties that are set using a vertex buffer and can be different for individual vertices.
                Uniforms are properties that are constant per draw call.
                They can be set using the <title_reference>shader.uniform_*</title_reference> functions after the shader has been bound.</paragraph>
        </section>
        <section ids="batch-creation" names="batch\ creation">
            <title>Batch Creation</title>
            <paragraph>Batches can be creates by first manually creating VBOs and IBOs.
                However, it is recommended to use the <reference internal="True" reftitle="gpu_extras.batch.batch_for_shader" refuri="gpu_extras.batch#gpu_extras.batch.batch_for_shader"><literal classes="xref py py-class">gpu_extras.batch.batch_for_shader</literal></reference> function.
                It makes sure that all the vertex attributes necessary for a specific shader are provided.
                Consequently, the shader has to be passed to the function as well.
                When using this function one rarely has to care about the vertex format, VBOs and IBOs created in the background.
                This is still something one should know when drawing stuff though.</paragraph>
            <paragraph>Since batches can be drawn multiple times, they should be cached and reused whenever possible.</paragraph>
        </section>
        <section ids="offscreen-rendering" names="offscreen\ rendering">
            <title>Offscreen Rendering</title>
            <paragraph>What one can see on the screen after rendering is called the <emphasis>Front Buffer</emphasis>.
                When draw calls are issued, batches are drawn on a <emphasis>Back Buffer</emphasis> that will only be displayed
                when all drawing is done and the current back buffer will become the new front buffer.
                Sometimes, one might want to draw the batches into a distinct buffer that could be used as
                texture to display on another object or to be saved as image on disk.
                This is called Offscreen Rendering.
                In Blender Offscreen Rendering is done using the <reference internal="True" reftitle="gpu.types.GPUOffScreen" refuri="gpu.types#gpu.types.GPUOffScreen"><literal classes="xref py py-class">gpu.types.GPUOffScreen</literal></reference> type.</paragraph>
            <warning>
                <paragraph><title_reference>GPUOffScreen</title_reference> objects are bound to the OpenGL context they have been created in.
                    This means that once Blender discards this context (i.e. the window is closed),
                    the offscreen instance will be freed.</paragraph>
            </warning>
        </section>
        <section ids="examples" names="examples">
            <title>Examples</title>
            <paragraph>To try these examples, just copy them into Blenders text editor and execute them.
                To keep the examples relatively small, they just register a draw function that can’t easily be removed anymore.
                Blender has to be restarted in order to delete the draw handlers.</paragraph>
            <section ids="d-lines-with-single-color" names="3d\ lines\ with\ single\ color">
                <title>3D Lines with Single Color</title>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/examples/gpu.2.py" xml:space="preserve">import bpy
import gpu
from gpu_extras.batch import batch_for_shader

coords = [(1, 1, 1), (-2, 0, 0), (-2, -1, 3), (0, 1, 1)]
shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')
batch = batch_for_shader(shader, 'LINES', {"pos": coords})


def draw():
    shader.bind()
    shader.uniform_float("color", (1, 1, 0, 1))
    batch.draw(shader)


bpy.types.SpaceView3D.draw_handler_add(draw, (), 'WINDOW', 'POST_VIEW')
</literal_block>
            </section>
            <section ids="triangle-with-custom-shader" names="triangle\ with\ custom\ shader">
                <title>Triangle with Custom Shader</title>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/examples/gpu.3.py" xml:space="preserve">import bpy
import gpu
from gpu_extras.batch import batch_for_shader

vertex_shader = '''
    uniform mat4 viewProjectionMatrix;

    in vec3 position;
    out vec3 pos;

    void main()
    {
        pos = position;
        gl_Position = viewProjectionMatrix * vec4(position, 1.0f);
    }
'''

fragment_shader = '''
    uniform float brightness;

    in vec3 pos;

    void main()
    {
        gl_FragColor = vec4(pos * brightness, 1.0);
    }
'''

coords = [(1, 1, 1), (2, 0, 0), (-2, -1, 3)]
shader = gpu.types.GPUShader(vertex_shader, fragment_shader)
batch = batch_for_shader(shader, 'TRIS', {"position": coords})


def draw():
    shader.bind()
    matrix = bpy.context.region_data.perspective_matrix
    shader.uniform_float("viewProjectionMatrix", matrix)
    shader.uniform_float("brightness", 0.5)
    batch.draw(shader)


bpy.types.SpaceView3D.draw_handler_add(draw, (), 'WINDOW', 'POST_VIEW')
</literal_block>
            </section>
            <section ids="wireframe-cube-using-index-buffer" names="wireframe\ cube\ using\ index\ buffer">
                <title>Wireframe Cube using Index Buffer</title>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/examples/gpu.4.py" xml:space="preserve">import bpy
import gpu
from gpu_extras.batch import batch_for_shader

coords = (
    (-1, -1, -1), (+1, -1, -1),
    (-1, +1, -1), (+1, +1, -1),
    (-1, -1, +1), (+1, -1, +1),
    (-1, +1, +1), (+1, +1, +1))

indices = (
    (0, 1), (0, 2), (1, 3), (2, 3),
    (4, 5), (4, 6), (5, 7), (6, 7),
    (0, 4), (1, 5), (2, 6), (3, 7))

shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')
batch = batch_for_shader(shader, 'LINES', {"pos": coords}, indices=indices)


def draw():
    shader.bind()
    shader.uniform_float("color", (1, 0, 0, 1))
    batch.draw(shader)


bpy.types.SpaceView3D.draw_handler_add(draw, (), 'WINDOW', 'POST_VIEW')
</literal_block>
            </section>
            <section ids="mesh-with-random-vertex-colors" names="mesh\ with\ random\ vertex\ colors">
                <title>Mesh with Random Vertex Colors</title>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/examples/gpu.5.py" xml:space="preserve">import bpy
import gpu
import numpy as np
from random import random
from gpu_extras.batch import batch_for_shader

mesh = bpy.context.active_object.data
mesh.calc_loop_triangles()

vertices = np.empty((len(mesh.vertices), 3), 'f')
indices = np.empty((len(mesh.loop_triangles), 3), 'i')

mesh.vertices.foreach_get(
    "co", np.reshape(vertices, len(mesh.vertices) * 3))
mesh.loop_triangles.foreach_get(
    "vertices", np.reshape(indices, len(mesh.loop_triangles) * 3))

vertex_colors = [(random(), random(), random(), 1) for _ in range(len(mesh.vertices))]

shader = gpu.shader.from_builtin('3D_SMOOTH_COLOR')
batch = batch_for_shader(
    shader, 'TRIS',
    {"pos": vertices, "color": vertex_colors},
    indices=indices,
)


def draw():
    batch.draw(shader)


bpy.types.SpaceView3D.draw_handler_add(draw, (), 'WINDOW', 'POST_VIEW')
</literal_block>
            </section>
            <section ids="d-rectangle" names="2d\ rectangle">
                <title>2D Rectangle</title>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/examples/gpu.6.py" xml:space="preserve">import bpy
import gpu
from gpu_extras.batch import batch_for_shader

vertices = (
    (100, 100), (300, 100),
    (100, 200), (300, 200))

indices = (
    (0, 1, 2), (2, 1, 3))

shader = gpu.shader.from_builtin('2D_UNIFORM_COLOR')
batch = batch_for_shader(shader, 'TRIS', {"pos": vertices}, indices=indices)


def draw():
    shader.bind()
    shader.uniform_float("color", (0, 0.5, 0.5, 1.0))
    batch.draw(shader)


bpy.types.SpaceView3D.draw_handler_add(draw, (), 'WINDOW', 'POST_PIXEL')
</literal_block>
            </section>
            <section ids="d-image" names="2d\ image">
                <title>2D Image</title>
                <paragraph>To use this example you have to provide an image that should be displayed.</paragraph>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/examples/gpu.7.py" xml:space="preserve">import bpy
import gpu
import bgl
from gpu_extras.batch import batch_for_shader

IMAGE_NAME = "Untitled"
image = bpy.data.images[IMAGE_NAME]

shader = gpu.shader.from_builtin('2D_IMAGE')
batch = batch_for_shader(
    shader, 'TRI_FAN',
    {
        "pos": ((100, 100), (200, 100), (200, 200), (100, 200)),
        "texCoord": ((0, 0), (1, 0), (1, 1), (0, 1)),
    },
)

if image.gl_load():
    raise Exception()


def draw():
    bgl.glActiveTexture(bgl.GL_TEXTURE0)
    bgl.glBindTexture(bgl.GL_TEXTURE_2D, image.bindcode)

    shader.bind()
    shader.uniform_int("image", 0)
    batch.draw(shader)


bpy.types.SpaceView3D.draw_handler_add(draw, (), 'WINDOW', 'POST_PIXEL')
</literal_block>
            </section>
            <section ids="generate-a-texture-using-offscreen-rendering" names="generate\ a\ texture\ using\ offscreen\ rendering">
                <title>Generate a texture using Offscreen Rendering</title>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Create an <reference internal="True" reftitle="gpu.types.GPUOffScreen" refuri="gpu.types#gpu.types.GPUOffScreen"><literal classes="xref py py-class">gpu.types.GPUOffScreen</literal></reference> object.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Draw some circles into it.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Make a new shader for drawing a planar texture in 3D.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Draw the generated texture using the new shader.</paragraph>
                    </list_item>
                </enumerated_list>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/examples/gpu.8.py" xml:space="preserve">import bpy
import gpu
import bgl
from mathutils import Matrix
from gpu_extras.batch import batch_for_shader
from gpu_extras.presets import draw_circle_2d

# Create and fill offscreen
##########################################

offscreen = gpu.types.GPUOffScreen(512, 512)

with offscreen.bind():
    bgl.glClear(bgl.GL_COLOR_BUFFER_BIT)
    with gpu.matrix.push_pop():
        # reset matrices -&gt; use normalized device coordinates [-1, 1]
        gpu.matrix.load_matrix(Matrix.Identity(4))
        gpu.matrix.load_projection_matrix(Matrix.Identity(4))

        amount = 10
        for i in range(-amount, amount + 1):
            x_pos = i / amount
            draw_circle_2d((x_pos, 0.0), (1, 1, 1, 1), 0.5, 200)


# Drawing the generated texture in 3D space
#############################################

vertex_shader = '''
    uniform mat4 modelMatrix;
    uniform mat4 viewProjectionMatrix;

    in vec2 position;
    in vec2 uv;

    out vec2 uvInterp;

    void main()
    {
        uvInterp = uv;
        gl_Position = viewProjectionMatrix * modelMatrix * vec4(position, 0.0, 1.0);
    }
'''

fragment_shader = '''
    uniform sampler2D image;

    in vec2 uvInterp;

    void main()
    {
        gl_FragColor = texture(image, uvInterp);
    }
'''

shader = gpu.types.GPUShader(vertex_shader, fragment_shader)
batch = batch_for_shader(
    shader, 'TRI_FAN',
    {
        "position": ((-1, -1), (1, -1), (1, 1), (-1, 1)),
        "uv": ((0, 0), (1, 0), (1, 1), (0, 1)),
    },
)


def draw():
    bgl.glActiveTexture(bgl.GL_TEXTURE0)
    bgl.glBindTexture(bgl.GL_TEXTURE_2D, offscreen.color_texture)

    shader.bind()
    shader.uniform_float("modelMatrix", Matrix.Translation((1, 2, 3)) @ Matrix.Scale(3, 4))
    shader.uniform_float("viewProjectionMatrix", bpy.context.region_data.perspective_matrix)
    shader.uniform_float("image", 0)
    batch.draw(shader)


bpy.types.SpaceView3D.draw_handler_add(draw, (), 'WINDOW', 'POST_VIEW')
</literal_block>
            </section>
            <section ids="copy-offscreen-rendering-result-back-to-ram" names="copy\ offscreen\ rendering\ result\ back\ to\ ram">
                <title>Copy Offscreen Rendering result back to RAM</title>
                <paragraph>This will create a new image with the given name.
                    If it already exists, it will override the existing one.</paragraph>
                <paragraph>Currently almost all of the execution time is spent in the last line.
                    In the future this will hopefully be solved by implementing the Python buffer protocol
                    for <reference internal="True" reftitle="bgl.Buffer" refuri="bgl#bgl.Buffer"><literal classes="xref py py-class">bgl.Buffer</literal></reference> and <reference internal="True" reftitle="bpy.types.Image.pixels" refuri="bpy.types.Image#bpy.types.Image.pixels"><literal classes="xref py py-class">bpy.types.Image.pixels</literal></reference> (aka <literal>bpy_prop_array</literal>).</paragraph>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/examples/gpu.9.py" xml:space="preserve">import bpy
import gpu
import bgl
import random
from mathutils import Matrix
from gpu_extras.presets import draw_circle_2d

IMAGE_NAME = "Generated Image"
WIDTH = 512
HEIGHT = 512
RING_AMOUNT = 10


offscreen = gpu.types.GPUOffScreen(WIDTH, HEIGHT)

with offscreen.bind():
    bgl.glClear(bgl.GL_COLOR_BUFFER_BIT)
    with gpu.matrix.push_pop():
        # reset matrices -&gt; use normalized device coordinates [-1, 1]
        gpu.matrix.load_matrix(Matrix.Identity(4))
        gpu.matrix.load_projection_matrix(Matrix.Identity(4))

        for i in range(RING_AMOUNT):
            draw_circle_2d(
                (random.uniform(-1, 1), random.uniform(-1, 1)),
                (1, 1, 1, 1), random.uniform(0.1, 1), 20)

    buffer = bgl.Buffer(bgl.GL_BYTE, WIDTH * HEIGHT * 4)
    bgl.glReadBuffer(bgl.GL_BACK)
    bgl.glReadPixels(0, 0, WIDTH, HEIGHT, bgl.GL_RGBA, bgl.GL_UNSIGNED_BYTE, buffer)

offscreen.free()


if not IMAGE_NAME in bpy.data.images:
    bpy.data.images.new(IMAGE_NAME, WIDTH, HEIGHT)
image = bpy.data.images[IMAGE_NAME]
image.scale(WIDTH, HEIGHT)
image.pixels = [v / 255 for v in buffer]
</literal_block>
            </section>
            <section ids="rendering-the-3d-view-into-a-texture" names="rendering\ the\ 3d\ view\ into\ a\ texture">
                <title>Rendering the 3D View into a Texture</title>
                <paragraph>The scene has to have a camera for this example to work.
                    You could also make this independent of a specific camera,
                    but Blender does not expose good functions to create view and projection matrices yet.</paragraph>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/examples/gpu.10.py" xml:space="preserve">import bpy
import bgl
import gpu
from gpu_extras.presets import draw_texture_2d

WIDTH = 512
HEIGHT = 256

offscreen = gpu.types.GPUOffScreen(WIDTH, HEIGHT)


def draw():
    context = bpy.context
    scene = context.scene

    view_matrix = scene.camera.matrix_world.inverted()

    projection_matrix = scene.camera.calc_matrix_camera(
        context.depsgraph, x=WIDTH, y=HEIGHT)

    offscreen.draw_view3d(
        scene,
        context.view_layer,
        context.space_data,
        context.region,
        view_matrix,
        projection_matrix)

    bgl.glDisable(bgl.GL_DEPTH_TEST)
    draw_texture_2d(offscreen.color_texture, (10, 10), WIDTH, HEIGHT)


bpy.types.SpaceView3D.draw_handler_add(draw, (), 'WINDOW', 'POST_PIXEL')
</literal_block>
            </section>
            <section ids="custom-shader-for-dotted-3d-line" names="custom\ shader\ for\ dotted\ 3d\ line">
                <title>Custom Shader for dotted 3D Line</title>
                <paragraph>In this example the arc length (distance to the first point on the line) is calculated in every vertex.
                    Between the vertex and fragment shader that value is automatically interpolated
                    for all points that will be visible on the screen.
                    In the fragment shader the <literal>sin</literal> of the arc length is calculated.
                    Based on the result a decision is made on whether the fragment should be drawn or not.</paragraph>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/examples/gpu.11.py" xml:space="preserve">import bpy
import gpu
from random import random
from mathutils import Vector
from gpu_extras.batch import batch_for_shader

vertex_shader = '''
    uniform mat4 u_ViewProjectionMatrix;

    in vec3 position;
    in float arcLength;

    out float v_ArcLength;

    void main()
    {
        v_ArcLength = arcLength;
        gl_Position = u_ViewProjectionMatrix * vec4(position, 1.0f);
    }
'''

fragment_shader = '''
    uniform float u_Scale;

    in float v_ArcLength;

    void main()
    {
        if (step(sin(v_ArcLength * u_Scale), 0.5) == 1) discard;
        gl_FragColor = vec4(1.0);
    }
'''

coords = [Vector((random(), random(), random())) * 5 for _ in range(5)]

arc_lengths = [0]
for a, b in zip(coords[:-1], coords[1:]):
    arc_lengths.append(arc_lengths[-1] + (a - b).length)

shader = gpu.types.GPUShader(vertex_shader, fragment_shader)
batch = batch_for_shader(
    shader, 'LINE_STRIP',
    {"position": coords, "arcLength": arc_lengths},
)


def draw():
    shader.bind()
    matrix = bpy.context.region_data.perspective_matrix
    shader.uniform_float("u_ViewProjectionMatrix", matrix)
    shader.uniform_float("u_Scale", 10)
    batch.draw(shader)


bpy.types.SpaceView3D.draw_handler_add(draw, (), 'WINDOW', 'POST_VIEW')
</literal_block>
            </section>
        </section>
    </section>
</document>
