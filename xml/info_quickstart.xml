<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.14 -->
<document source="/home/zicklag/git/other/blender/doc/python_api/sphinx-in/info_quickstart.rst">
    <target refid="info-quickstart"></target>
    <section ids="quickstart-introduction info-quickstart" names="quickstart\ introduction info_quickstart">
        <title>Quickstart Introduction</title>
        <section ids="preface" names="preface">
            <title>Preface</title>
            <paragraph>This API is generally stable but some areas are still being added and improved.</paragraph>
            <paragraph>The Blender/Python API can do the following:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Edit any data the user interface can (Scenes, Meshes, Particles etc.)</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Modify user preferences, keymaps and themes</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Run tools with own settings</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Create user interface elements such as menus, headers and panels</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Create new tools</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Create interactive tools</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Create new rendering engines that integrate with Blender</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Define new settings in existing Blender data</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Draw in the 3D view using OpenGL commands from Python</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The Blender/Python API <strong>can’t</strong> (yet)…</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Create new space types.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Assign custom properties to every type.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Define callbacks or listeners to be notified when data is changed.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="before-starting" names="before\ starting">
            <title>Before Starting</title>
            <paragraph>This document isn’t intended to fully cover each topic.
                Rather, its purpose is to familiarize you with Blender Python API.</paragraph>
            <paragraph>A quick list of helpful things to know before starting:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Blender uses Python 3.x; some online documentation still assumes 2.x.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The interactive console is great for testing one-liners.
                        It also has autocompletion so you can inspect the API quickly.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Button tool tips show Python attributes and operator names.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Right clicking on buttons and menu items directly links to API documentation.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>For more examples, the text menu has a templates section where some example operators can be found.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>To examine further scripts distributed with Blender, see:</paragraph>
                    <line_block>
                        <line><literal>scripts/startup/bl_ui</literal> for the user interface,</line>
                        <line><literal>scripts/startup/bl_operators</literal> for operators.</line>
                    </line_block>
                    <paragraph>Exact location depends on platform, see:
                        <inline classes="xref std std-ref">Configuration and Data Paths</inline>.</paragraph>
                </list_item>
            </bullet_list>
            <section ids="running-scripts" names="running\ scripts">
                <title>Running Scripts</title>
                <paragraph>The two most common ways to execute Python scripts are using the built-in
                    text editor or entering commands in the Python console.</paragraph>
                <paragraph>Both the <emphasis>Text Editor</emphasis> and <emphasis>Python Console</emphasis> are space types you can select from the view header.</paragraph>
                <paragraph>Rather than manually configuring your spaces for Python development,
                    you may prefer to use the <emphasis>Scripting</emphasis> screen, included default with Blender,
                    accessible from the top headers screen selector.</paragraph>
                <paragraph>From the text editor you can open <literal>.py</literal> files or paste then from the clipboard, then test using <emphasis>Run Script</emphasis>.</paragraph>
                <paragraph>The Python Console is typically used for typing in snippets and for testing to get immediate feedback,
                    but can also have entire scripts pasted into it.</paragraph>
                <paragraph>Scripts can also run from the command line with Blender but to learn Blender/Python this isn’t essential.</paragraph>
            </section>
        </section>
        <section ids="key-concepts" names="key\ concepts">
            <title>Key Concepts</title>
            <section ids="data-access" names="data\ access">
                <title>Data Access</title>
                <section ids="accessing-datablocks" names="accessing\ datablocks">
                    <title>Accessing DataBlocks</title>
                    <paragraph>Python accesses Blender’s data in the same way as the animation system and user interface;
                        this implies that any setting that can be changed via a button can also be changed from Python.</paragraph>
                    <paragraph>Accessing data from the currently loaded blend file is done with the module <reference internal="True" reftitle="bpy.data" refuri="bpy.data#bpy.data"><literal classes="xref py py-mod">bpy.data</literal></reference>.
                        This gives access to library data. For example:</paragraph>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.data.objects
&lt;bpy_collection[3], BlendDataObjects&gt;</doctest_block>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.data.scenes
&lt;bpy_collection[1], BlendDataScenes&gt;</doctest_block>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.data.materials
&lt;bpy_collection[1], BlendDataMaterials&gt;</doctest_block>
                </section>
                <section ids="about-collections" names="about\ collections">
                    <title>About Collections</title>
                    <paragraph>You’ll notice that an index as well as a string can be used to access members of the collection.</paragraph>
                    <paragraph>Unlike Python’s dictionaries, both methods are acceptable;
                        however, the index of a member may change while running Blender.</paragraph>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; list(bpy.data.objects)
[bpy.data.objects["Cube"], bpy.data.objects["Plane"]]</doctest_block>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.data.objects['Cube']
bpy.data.objects["Cube"]</doctest_block>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.data.objects[0]
bpy.data.objects["Cube"]</doctest_block>
                </section>
                <section ids="accessing-attributes" names="accessing\ attributes">
                    <title>Accessing Attributes</title>
                    <paragraph>Once you have a data block, such as a material, object, collections etc.,
                        its attributes can be accessed much like you would change a setting using the graphical interface.
                        In fact, the tooltip for each button also displays the Python attribute
                        which can help in finding what settings to change in a script.</paragraph>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.data.objects[0].name
'Camera'</doctest_block>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.data.scenes["Scene"]
bpy.data.scenes['Scene']</doctest_block>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.data.materials.new("MyMaterial")
bpy.data.materials['MyMaterial']</doctest_block>
                    <paragraph>For testing what data to access it’s useful to use the “Console”, which is its own space type.
                        This supports auto-complete, giving you a fast way to dig into different data in your file.</paragraph>
                    <paragraph>Example of a data path that can be quickly found via the console:</paragraph>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.data.scenes[0].render.resolution_percentage
100
&gt;&gt;&gt; bpy.data.scenes[0].objects["Torus"].data.vertices[0].co.x
1.0</doctest_block>
                </section>
                <section ids="data-creation-removal" names="data\ creation/removal">
                    <title>Data Creation/Removal</title>
                    <paragraph>Those of you familiar with other Python API’s may be surprised that
                        new data-blocks in the bpy API can’t be created by calling the class:</paragraph>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.types.Mesh()
Traceback (most recent call last):
  File "&lt;blender_console&gt;", line 1, in &lt;module&gt;
TypeError: bpy_struct.__new__(type): expected a single argument</doctest_block>
                    <paragraph>This is an intentional part of the API design.
                        The Blender/Python API can’t create Blender data that exists outside the main Blender database
                        (accessed through <reference internal="True" reftitle="bpy.data" refuri="bpy.data#bpy.data"><literal classes="xref py py-mod">bpy.data</literal></reference>), because this data is managed by Blender (save/load/undo/append… etc).</paragraph>
                    <paragraph>Data is added and removed via methods on the collections in <reference internal="True" reftitle="bpy.data" refuri="bpy.data#bpy.data"><literal classes="xref py py-mod">bpy.data</literal></reference>, eg:</paragraph>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; mesh = bpy.data.meshes.new(name="MyMesh")
&gt;&gt;&gt; print(mesh)
&lt;bpy_struct, Mesh("MyMesh.001")&gt;</doctest_block>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.data.meshes.remove(mesh)</doctest_block>
                </section>
                <section ids="custom-properties" names="custom\ properties">
                    <title>Custom Properties</title>
                    <paragraph>Python can access properties on any datablock that has an ID
                        (data that can be linked in and accessed from <reference internal="True" reftitle="bpy.data" refuri="bpy.data#bpy.data"><literal classes="xref py py-mod">bpy.data</literal></reference>.
                        When assigning a property, you can make up your own names,
                        these will be created when needed or overwritten if they exist.</paragraph>
                    <paragraph>This data is saved with the blend file and copied with objects.</paragraph>
                    <paragraph>Example:</paragraph>
                    <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.context.object["MyOwnProperty"] = 42

if "SomeProp" in bpy.context.object:
    print("Property found")

# Use the get function like a Python dictionary
# which can have a fallback value.
value = bpy.data.scenes["Scene"].get("test_prop", "fallback value")

# dictionaries can be assigned as long as they only use basic types.
collection = bpy.data.collections.new("MyTestCollection")
collection["MySettings"] = {"foo": 10, "bar": "spam", "baz": {}}

del collection["MySettings"]</literal_block>
                    <paragraph>Note that these properties can only be assigned  basic Python types.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>int, float, string</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>array of ints/floats</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>dictionary (only string keys are supported, values must be basic types too)</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>These properties are valid outside of Python. They can be animated by curves or used in driver paths.</paragraph>
                </section>
            </section>
            <section ids="context" names="context">
                <title>Context</title>
                <paragraph>While it’s useful to be able to access data directly by name or as a list,
                    it’s more common to operate on the user’s selection.
                    The context is always available from <literal>bpy.context</literal> and can be used to get the active object, scene,
                    tool settings along with many other attributes.</paragraph>
                <paragraph>Common-use cases:</paragraph>
                <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.context.object
&gt;&gt;&gt; bpy.context.selected_objects
&gt;&gt;&gt; bpy.context.visible_bones</doctest_block>
                <paragraph>Note that the context is read-only.
                    These values cannot be modified directly,
                    though they may be changed by running API functions or by using the data API.</paragraph>
                <paragraph>So <literal>bpy.context.object = obj</literal> will raise an error.</paragraph>
                <paragraph>But <literal>bpy.context.scene.objects.active = obj</literal> will work as expected.</paragraph>
                <paragraph>The context attributes change depending on where they are accessed.
                    The 3D view has different context members than the console,
                    so take care when accessing context attributes that the user state is known.</paragraph>
                <paragraph>See <reference internal="True" reftitle="bpy.context" refuri="bpy.context#module-bpy.context"><literal classes="xref py py-mod">bpy.context</literal></reference> API reference.</paragraph>
            </section>
            <section ids="operators-tools" names="operators\ (tools)">
                <title>Operators (Tools)</title>
                <paragraph>Operators are tools generally accessed by the user from buttons, menu items or key shortcuts.
                    From the user perspective they are a tool but Python can run these with its own settings
                    through the <literal classes="xref py py-mod">bpy.ops</literal> module.</paragraph>
                <paragraph>Examples:</paragraph>
                <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.ops.mesh.flip_normals()
{'FINISHED'}
&gt;&gt;&gt; bpy.ops.mesh.hide(unselected=False)
{'FINISHED'}
&gt;&gt;&gt; bpy.ops.object.scale_apply()
{'FINISHED'}</doctest_block>
                <note>
                    <paragraph>The menu item: <inline classes="menuselection" rawtext=":menuselection:`Help --&gt; Operator Cheat Sheet`">Help ‣ Operator Cheat Sheet</inline>
                        gives a list of all operators and their default values in Python syntax, along with the generated docs.
                        This is a good way to get an overview of all Blender’s operators.</paragraph>
                </note>
                <section ids="operator-poll" names="operator\ poll()">
                    <title>Operator Poll()</title>
                    <paragraph>Many operators have a “poll” function which may check that the cursor
                        is in a valid area or that the object is in the correct mode (Edit Mode, Weight Paint etc).
                        When an operator’s poll function fails within Python, an exception is raised.</paragraph>
                    <paragraph>For example, calling <literal>bpy.ops.view3d.render_border()</literal> from the console raises the following error:</paragraph>
                    <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">RuntimeError: Operator bpy.ops.view3d.render_border.poll() failed, context is incorrect</literal_block>
                    <paragraph>In this case the context must be the 3d view with an active camera.</paragraph>
                    <paragraph>To avoid using try/except clauses wherever operators are called you can call the operators
                        own <literal>poll()</literal> function to check if it can run in the current context.</paragraph>
                    <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">if bpy.ops.view3d.render_border.poll():
    bpy.ops.view3d.render_border()</literal_block>
                </section>
            </section>
        </section>
        <section ids="integration" names="integration">
            <title>Integration</title>
            <paragraph>Python scripts can integrate with Blender in the following ways:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>By defining a rendering engine.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>By defining operators.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>By defining menus, headers and panels.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>By inserting new buttons into existing menus, headers and panels</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>In Python, this is done by defining a class, which is a subclass of an existing type.</paragraph>
            <section ids="example-operator" names="example\ operator">
                <title>Example Operator</title>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/sphinx-in/__/__/__/release/scripts/templates_py/operator_simple.py" xml:space="preserve">import bpy


def main(context):
    for ob in context.scene.objects:
        print(ob)


class SimpleOperator(bpy.types.Operator):
    """Tooltip"""
    bl_idname = "object.simple_operator"
    bl_label = "Simple Object Operator"

    @classmethod
    def poll(cls, context):
        return context.active_object is not None

    def execute(self, context):
        main(context)
        return {'FINISHED'}


def register():
    bpy.utils.register_class(SimpleOperator)


def unregister():
    bpy.utils.unregister_class(SimpleOperator)


if __name__ == "__main__":
    register()

    # test call
    bpy.ops.object.simple_operator()
</literal_block>
                <paragraph>Once this script runs, <literal>SimpleOperator</literal> is registered with Blender
                    and can be called from the operator search popup or added to the toolbar.</paragraph>
                <paragraph>To run the script:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Highlight the above code then press <literal classes="kbd">Ctrl-C</literal> to copy it.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Start Blender</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Press <literal classes="kbd">Ctrl-Right</literal> twice to change to the Scripting layout.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Click the button labeled <literal>New</literal> and the confirmation pop up in order to create a new text block.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Press <literal classes="kbd">Ctrl-V</literal> to paste the code into the text panel (the upper left frame).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Click on the button <strong>Run Script</strong>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Move your cursor into the 3D view, press spacebar for the operator search menu, and type “Simple”.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Click on the “Simple Operator” item found in search.</paragraph>
                    </list_item>
                </enumerated_list>
                <seealso>
                    <paragraph>The class members with the <literal>bl_</literal> prefix are documented in the API
                        reference <reference internal="True" reftitle="bpy.types.Operator" refuri="bpy.types.Operator#bpy.types.Operator"><literal classes="xref py py-class">bpy.types.Operator</literal></reference></paragraph>
                </seealso>
                <note>
                    <paragraph>The output from the <literal>main</literal> function is sent to the terminal;
                        in order to see this, be sure to <reference internal="True" refuri="info_tips_and_tricks#use-the-terminal"><inline classes="std std-ref">use the terminal</inline></reference>.</paragraph>
                </note>
            </section>
            <section ids="example-panel" names="example\ panel">
                <title>Example Panel</title>
                <paragraph>Panels register themselves as a class, like an operator.
                    Notice the extra <literal>bl_</literal> variables used to set the context they display in.</paragraph>
                <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/sphinx-in/__/__/__/release/scripts/templates_py/ui_panel_simple.py" xml:space="preserve">import bpy


class HelloWorldPanel(bpy.types.Panel):
    """Creates a Panel in the Object properties window"""
    bl_label = "Hello World Panel"
    bl_idname = "OBJECT_PT_hello"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "object"

    def draw(self, context):
        layout = self.layout

        obj = context.object

        row = layout.row()
        row.label(text="Hello world!", icon='WORLD_DATA')

        row = layout.row()
        row.label(text="Active object is: " + obj.name)
        row = layout.row()
        row.prop(obj, "name")

        row = layout.row()
        row.operator("mesh.primitive_cube_add")


def register():
    bpy.utils.register_class(HelloWorldPanel)


def unregister():
    bpy.utils.unregister_class(HelloWorldPanel)


if __name__ == "__main__":
    register()
</literal_block>
                <paragraph>To run the script:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Highlight the above code then press <literal classes="kbd">Ctrl-C</literal> to copy it.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Start Blender.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Click on the tab for the <emphasis>Scripting</emphasis> workspace.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Click the button labeled <literal>New</literal> to create a new text block.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Press <literal classes="kbd">Ctrl-V</literal> to paste the code into the text panel (the upper left frame).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Click on the button <strong>Run Script</strong>.</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>To view the results:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Select the the default cube.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Click on the Object properties icon in the buttons panel (far right; appears as a tiny cube).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Scroll down to see a panel named <strong>Hello World Panel</strong>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Changing the object name also updates <strong>Hello World Panel’s</strong> Name: field.</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>Note the row distribution and the label and properties that are available through the code.</paragraph>
                <seealso>
                    <paragraph><reference internal="True" reftitle="bpy.types.Panel" refuri="bpy.types.Panel#bpy.types.Panel"><literal classes="xref py py-class">bpy.types.Panel</literal></reference></paragraph>
                </seealso>
            </section>
        </section>
        <section ids="types" names="types">
            <title>Types</title>
            <paragraph>Blender defines a number of Python types but also uses Python native types.</paragraph>
            <paragraph>Blender’s Python API can be split up into 3 categories.</paragraph>
            <section ids="native-types" names="native\ types">
                <title>Native Types</title>
                <paragraph>In simple cases returning a number or a string as a custom type would be cumbersome,
                    so these are accessed as normal Python types.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Blender float/int/boolean -&gt; float/int/boolean</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Blender enumerator -&gt; string</paragraph>
                        <doctest_block xml:space="preserve">&gt;&gt;&gt; C.object.rotation_mode = 'AXIS_ANGLE'</doctest_block>
                    </list_item>
                    <list_item>
                        <paragraph>Blender enumerator (multiple) -&gt; set of strings</paragraph>
                        <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># setting multiple camera overlay guides
bpy.context.scene.camera.data.show_guide = {'GOLDEN', 'CENTER'}

# passing as an operator argument for report types
self.report({'WARNING', 'INFO'}, "Some message!")</literal_block>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="internal-types" names="internal\ types">
                <title>Internal Types</title>
                <paragraph>Used for Blender data-blocks and collections: <reference internal="True" reftitle="bpy.types.bpy_struct" refuri="bpy.types.bpy_struct#bpy.types.bpy_struct"><literal classes="xref py py-class">bpy.types.bpy_struct</literal></reference></paragraph>
                <paragraph>For data that contains its own attributes collections/meshes/bones/scenes… etc.</paragraph>
                <paragraph>There are 2 main types that wrap Blenders data, one for data-blocks
                    (known internally as <literal>bpy_struct</literal>), another for properties.</paragraph>
                <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.context.object
bpy.data.objects['Cube']</doctest_block>
                <doctest_block xml:space="preserve">&gt;&gt;&gt; C.scene.objects
bpy.data.scenes['Scene'].objects</doctest_block>
                <paragraph>Note that these types reference Blender’s data so modifying them is immediately visible.</paragraph>
            </section>
            <section ids="mathutils-types" names="mathutils\ types">
                <title>Mathutils Types</title>
                <paragraph>Used for vectors, quaternion, eulers, matrix and color types, accessible from <reference internal="True" reftitle="mathutils" refuri="mathutils#module-mathutils"><literal classes="xref py py-mod">mathutils</literal></reference></paragraph>
                <paragraph>Some attributes such as <reference internal="True" reftitle="bpy.types.Object.location" refuri="bpy.types.Object#bpy.types.Object.location"><literal classes="xref py py-class">bpy.types.Object.location</literal></reference>,
                    <reference internal="True" reftitle="bpy.types.PoseBone.rotation_euler" refuri="bpy.types.PoseBone#bpy.types.PoseBone.rotation_euler"><literal classes="xref py py-class">bpy.types.PoseBone.rotation_euler</literal></reference> and <reference internal="True" reftitle="bpy.types.Scene.cursor_location" refuri="bpy.types.Scene#bpy.types.Scene.cursor_location"><literal classes="xref py py-class">bpy.types.Scene.cursor_location</literal></reference>
                    can be accessed as special math types which can be used together and manipulated in various useful ways.</paragraph>
                <paragraph>Example of a matrix, vector multiplication:</paragraph>
                <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.context.object.matrix_world * bpy.context.object.data.verts[0].co</literal_block>
                <note>
                    <paragraph>mathutils types keep a reference to Blender’s internal data so changes can
                        be applied back.</paragraph>
                    <paragraph>Example:</paragraph>
                    <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># modifies the Z axis in place.
bpy.context.object.location.z += 2.0

# location variable holds a reference to the object too.
location = bpy.context.object.location
location *= 2.0

# Copying the value drops the reference so the value can be passed to
# functions and modified without unwanted side effects.
location = bpy.context.object.location.copy()</literal_block>
                </note>
            </section>
        </section>
        <section ids="animation" names="animation">
            <title>Animation</title>
            <paragraph>There are 2 ways to add keyframes through Python.</paragraph>
            <paragraph>The first is through key properties directly, which is similar to inserting a keyframe from the button as a user.
                You can also manually create the curves and keyframe data, then set the path to the property.
                Here are examples of both methods.</paragraph>
            <paragraph>Both examples insert a keyframe on the active object’s Z axis.</paragraph>
            <paragraph>Simple example:</paragraph>
            <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">obj = bpy.context.object
obj.location[2] = 0.0
obj.keyframe_insert(data_path="location", frame=10.0, index=2)
obj.location[2] = 1.0
obj.keyframe_insert(data_path="location", frame=20.0, index=2)</literal_block>
            <paragraph>Using Low-Level Functions:</paragraph>
            <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">obj = bpy.context.object
obj.animation_data_create()
obj.animation_data.action = bpy.data.actions.new(name="MyAction")
fcu_z = obj.animation_data.action.fcurves.new(data_path="location", index=2)
fcu_z.keyframe_points.add(2)
fcu_z.keyframe_points[0].co = 10.0, 0.0
fcu_z.keyframe_points[1].co = 20.0, 1.0</literal_block>
        </section>
    </section>
</document>
