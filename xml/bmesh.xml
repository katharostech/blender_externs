<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.14 -->
<document source="/home/zicklag/git/other/blender/doc/python_api/sphinx-in/bmesh.rst">
    <section ids="module-bmesh bmesh-module-bmesh" names="bmesh\ module\ (bmesh)">
        <title>BMesh Module (bmesh)</title>
        <index entries="['single',\ u'bmesh\ (module)',\ u'module-bmesh',\ '',\ None]"></index>
        <paragraph>This module provides access to blenders bmesh data structures.</paragraph>
        <comment xml:space="preserve">This document is appended to the auto generated bmesh api doc to avoid clogging up the C files with details.
to test this run:
./blender.bin -b -noaudio -P doc/python_api/sphinx_doc_gen.py -- \
              --partial bmesh* ; cd doc/python_api ; sphinx-build sphinx-in sphinx-out ; cd ../../</comment>
        <paragraph>Submodules:</paragraph>
        <compound classes="toctree-wrapper">
            <compact_paragraph toctree="True"><bullet_list><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="bmesh.ops">BMesh Operators (bmesh.ops)</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="bmesh.types">BMesh Types (bmesh.types)</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="bmesh.utils">BMesh Utilities (bmesh.utils)</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="bmesh.geometry">BMesh Geometry Utilities (bmesh.geometry)</reference></compact_paragraph></list_item></bullet_list></compact_paragraph>
        </compound>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>This API gives access the blenders internal mesh editing api, featuring geometry connectivity data and
                access to editing operations such as split, separate, collapse and dissolve.</paragraph>
            <paragraph>The features exposed closely follow the C API,
                giving python access to the functions used by blenders own mesh editing tools.</paragraph>
            <paragraph>For an overview of BMesh data types and how they reference each other see:
                <reference name="BMesh Design Document" refuri="https://wiki.blender.org/index.php/Dev:Source/Modeling/BMesh/Design">BMesh Design Document</reference><target ids="bmesh-design-document" names="bmesh\ design\ document" refuri="https://wiki.blender.org/index.php/Dev:Source/Modeling/BMesh/Design"></target> .</paragraph>
            <note>
                <paragraph><strong>Disk</strong> and <strong>Radial</strong> data is not exposed by the python api since this is for internal use only.</paragraph>
            </note>
            <warning>
                <paragraph>TODO items are…</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>add access to BMesh <strong>walkers</strong></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>add custom-data manipulation functions add/remove/rename.</paragraph>
                    </list_item>
                </bullet_list>
            </warning>
        </section>
        <section ids="example-script" names="example\ script">
            <title>Example Script</title>
            <literal_block force_highlighting="False" highlight_args="{'linenostart': 1}" language="default" linenos="False" source="/home/zicklag/git/other/blender/doc/python_api/sphinx-in/__/__/__/release/scripts/templates_py/bmesh_simple.py" xml:space="preserve"># This example assumes we have a mesh object selected

import bpy
import bmesh

# Get the active mesh
me = bpy.context.object.data


# Get a BMesh representation
bm = bmesh.new()   # create an empty BMesh
bm.from_mesh(me)   # fill it in from a Mesh


# Modify the BMesh, can do anything here...
for v in bm.verts:
    v.co.x += 1.0


# Finish up, write the bmesh back to the mesh
bm.to_mesh(me)
bm.free()  # free and prevent further access
</literal_block>
            <section ids="stand-alone-module" names="stand-alone\ module">
                <title>Stand-Alone Module</title>
                <paragraph>The bmesh module is written to be standalone except for <reference internal="True" reftitle="mathutils" refuri="mathutils#module-mathutils"><literal classes="xref py py-mod">mathutils</literal></reference>
                    which is used for vertex locations and normals.</paragraph>
                <paragraph>The only other exception to this are when converting mesh data to and from <reference internal="True" reftitle="bpy.types.Mesh" refuri="bpy.types.Mesh#bpy.types.Mesh"><literal classes="xref py py-class">bpy.types.Mesh</literal></reference>.</paragraph>
            </section>
        </section>
        <section ids="mesh-access" names="mesh\ access">
            <title>Mesh Access</title>
            <paragraph>There are 2 ways to access BMesh data, you can create a new BMesh by converting a mesh from
                <reference internal="True" reftitle="bpy.types.BlendData.meshes" refuri="bpy.types.BlendData#bpy.types.BlendData.meshes"><literal classes="xref py py-class">bpy.types.BlendData.meshes</literal></reference> or by accessing the current edit mode mesh.
                see: <reference internal="True" reftitle="bmesh.types.BMesh.from_mesh" refuri="bmesh.types#bmesh.types.BMesh.from_mesh"><literal classes="xref py py-class">bmesh.types.BMesh.from_mesh</literal></reference> and <reference internal="True" refid="bmesh.from_edit_mesh" reftitle="bmesh.from_edit_mesh"><literal classes="xref py py-mod">bmesh.from_edit_mesh</literal></reference> respectively.</paragraph>
            <paragraph>When explicitly converting from mesh data python <strong>owns</strong> the data, that is to say -
                that the mesh only exists while python holds a reference to it,
                and the script is responsible for putting it back into a mesh data-block when the edits are done.</paragraph>
            <paragraph>Note that unlike <reference internal="True" reftitle="bpy" refuri="bpy.data#module-bpy"><literal classes="xref py py-mod">bpy</literal></reference>, a BMesh does not necessarily correspond to data in the currently open blend file,
                a BMesh can be created, edited and freed without the user ever seeing or having access to it.
                Unlike edit mode, the bmesh module can use multiple BMesh instances at once.</paragraph>
            <paragraph>Take care when dealing with multiple BMesh instances since the mesh data can use a lot of memory, while a mesh that
                python owns will be freed in when the script holds no references to it,
                its good practice to call <reference internal="True" reftitle="bmesh.types.BMesh.free" refuri="bmesh.types#bmesh.types.BMesh.free"><literal classes="xref py py-class">bmesh.types.BMesh.free</literal></reference> which will remove all the mesh data immediately and disable
                further access.</paragraph>
            <section ids="editmode-tessellation" names="editmode\ tessellation">
                <title>EditMode Tessellation</title>
                <paragraph>When writing scripts that operate on editmode data you will normally want to re-calculate the tessellation after
                    running the  script, this needs to be called explicitly.</paragraph>
                <paragraph>The BMesh its self does not store the triangulated faces, they are stored in the <reference internal="True" reftitle="bpy.types.Mesh" refuri="bpy.types.Mesh#bpy.types.Mesh"><literal classes="xref py py-class">bpy.types.Mesh</literal></reference>,
                    to refresh tessellation triangles call <reference internal="True" reftitle="bpy.types.Mesh.calc_loop_triangles" refuri="bpy.types.Mesh#bpy.types.Mesh.calc_loop_triangles"><literal classes="xref py py-class">bpy.types.Mesh.calc_loop_triangles</literal></reference>.</paragraph>
            </section>
        </section>
        <section ids="customdata-access" names="customdata\ access">
            <title>CustomData Access</title>
            <paragraph>BMesh has a unified way to access mesh attributes such as UV’s vertex colors, shape keys, edge crease etc.</paragraph>
            <paragraph>This works by having a <strong>layers</strong> property on bmesh data sequences to access the custom data layers which can then be
                used to access the actual data on each vert/edge/face/loop.</paragraph>
            <paragraph>Here are some examples …</paragraph>
            <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">uv_lay = bm.loops.layers.uv.active

for face in bm.faces:
    for loop in face.loops:
        uv = loop[uv_lay].uv
        print("Loop UV: %f, %f" % uv[:])
        vert = loop.vert
        print("Loop Vert: (%f,%f,%f)" % vert.co[:])</literal_block>
            <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve">shape_lay = bm.verts.layers.shape["Key.001"]

for vert in bm.verts:
    shape = vert[shape_lay]
    print("Vert Shape: %f, %f, %f" % (shape.x, shape.y, shape.z))</literal_block>
            <literal_block force_highlighting="True" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># in this example the active vertex group index is used,
# this is stored in the object, not the BMesh
group_index = obj.vertex_groups.active_index

# only ever one deform weight layer
dvert_lay = bm.verts.layers.deform.active

for vert in bm.verts:
    dvert = vert[dvert_lay]

    if group_index in dvert:
        print("Weight %f" % dvert[group_index])
    else:
        print("Setting Weight")
        dvert[group_index] = 0.5</literal_block>
        </section>
        <section ids="keeping-a-correct-state" names="keeping\ a\ correct\ state">
            <title>Keeping a Correct State</title>
            <paragraph>When modeling in blender there are certain assumptions made about the state of the mesh.</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>hidden geometry isn’t selected.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>when an edge is selected, its vertices are selected too.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>when a face is selected, its edges and vertices are selected.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>duplicate edges / faces don’t exist.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>faces have at least 3 vertices.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>To give developers flexibility these conventions are not enforced,
                however tools must leave the mesh in a valid state else other tools may behave incorrectly.</paragraph>
            <paragraph>Any errors that arise from not following these conventions is considered a bug in the script,
                not a bug in blender.</paragraph>
            <section ids="selection-flushing" names="selection\ /\ flushing">
                <title>Selection / Flushing</title>
                <paragraph>As mentioned above, it is possible to create an invalid selection state
                    (by selecting a state and then de-selecting one of its vertices’s for example), mostly the best way to solve this is to
                    flush the selection after performing a series of edits. this validates the selection state.</paragraph>
            </section>
        </section>
        <section ids="module-functions" names="module\ functions">
            <title>Module Functions</title>
            <index entries="['single',\ u'from_edit_mesh()\ (in\ module\ bmesh)',\ u'bmesh.from_edit_mesh',\ '',\ None]"></index>
            <desc desctype="method" domain="py" noindex="False" objtype="method">
                <desc_signature class="" first="False" fullname="from_edit_mesh" ids="bmesh.from_edit_mesh" module="bmesh" names="bmesh.from_edit_mesh"><desc_addname xml:space="preserve">bmesh.</desc_addname><desc_name xml:space="preserve">from_edit_mesh</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve">mesh</desc_parameter></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Return a BMesh from this mesh, currently the mesh must already be in editmode.</paragraph>
                    <field_list>
                        <field>
                            <field_name>Parameters</field_name>
                            <field_body>
                                <paragraph><literal_strong refspecific="True">mesh</literal_strong> (<reference internal="True" reftitle="bpy.types.Mesh" refuri="bpy.types.Mesh#bpy.types.Mesh"><literal classes="xref py py-class">bpy.types.Mesh</literal></reference>) – The editmode mesh.</paragraph>
                            </field_body>
                        </field>
                        <field>
                            <field_name>Returns</field_name>
                            <field_body>
                                <paragraph>the BMesh associated with this mesh.</paragraph>
                            </field_body>
                        </field>
                        <field>
                            <field_name>Return type</field_name>
                            <field_body>
                                <paragraph><reference internal="True" reftitle="bmesh.types.BMesh" refuri="bmesh.types#bmesh.types.BMesh"><literal classes="xref py py-class">bmesh.types.BMesh</literal></reference></paragraph>
                            </field_body>
                        </field>
                    </field_list>
                </desc_content>
            </desc>
            <index entries="['single',\ u'new()\ (in\ module\ bmesh)',\ u'bmesh.new',\ '',\ None]"></index>
            <desc desctype="method" domain="py" noindex="False" objtype="method">
                <desc_signature class="" first="False" fullname="new" ids="bmesh.new" module="bmesh" names="bmesh.new"><desc_addname xml:space="preserve">bmesh.</desc_addname><desc_name xml:space="preserve">new</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve">use_operators=True</desc_parameter></desc_parameterlist></desc_signature>
                <desc_content>
                    <field_list>
                        <field>
                            <field_name>Parameters</field_name>
                            <field_body>
                                <paragraph><literal_strong refspecific="True">use_operators</literal_strong> (<literal_emphasis>bool</literal_emphasis>) – Support calling operators in <reference internal="True" reftitle="bmesh.ops" refuri="bmesh.ops#module-bmesh.ops"><literal classes="xref py py-mod">bmesh.ops</literal></reference> (uses some extra memory per vert/edge/face).</paragraph>
                            </field_body>
                        </field>
                        <field>
                            <field_name>Returns</field_name>
                            <field_body>
                                <paragraph>Return a new, empty BMesh.</paragraph>
                            </field_body>
                        </field>
                        <field>
                            <field_name>Return type</field_name>
                            <field_body>
                                <paragraph><reference internal="True" reftitle="bmesh.types.BMesh" refuri="bmesh.types#bmesh.types.BMesh"><literal classes="xref py py-class">bmesh.types.BMesh</literal></reference></paragraph>
                            </field_body>
                        </field>
                    </field_list>
                </desc_content>
            </desc>
            <index entries="['single',\ u'update_edit_mesh()\ (in\ module\ bmesh)',\ u'bmesh.update_edit_mesh',\ '',\ None]"></index>
            <desc desctype="method" domain="py" noindex="False" objtype="method">
                <desc_signature class="" first="False" fullname="update_edit_mesh" ids="bmesh.update_edit_mesh" module="bmesh" names="bmesh.update_edit_mesh"><desc_addname xml:space="preserve">bmesh.</desc_addname><desc_name xml:space="preserve">update_edit_mesh</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve">mesh</desc_parameter><desc_parameter xml:space="preserve">loop_triangles=True</desc_parameter><desc_parameter xml:space="preserve">destructive=True</desc_parameter></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Update the mesh after changes to the BMesh in editmode,
                        optionally recalculating n-gon tessellation.</paragraph>
                    <field_list>
                        <field>
                            <field_name>Parameters</field_name>
                            <field_body>
                                <bullet_list>
                                    <list_item>
                                        <paragraph><literal_strong refspecific="True">mesh</literal_strong> (<reference internal="True" reftitle="bpy.types.Mesh" refuri="bpy.types.Mesh#bpy.types.Mesh"><literal classes="xref py py-class">bpy.types.Mesh</literal></reference>) – The editmode mesh.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph><literal_strong refspecific="True">loop_triangles</literal_strong> (<literal_emphasis>boolean</literal_emphasis>) – Option to recalculate n-gon tessellation.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph><literal_strong refspecific="True">destructive</literal_strong> (<literal_emphasis>boolean</literal_emphasis>) – Use when geometry has been added or removed.</paragraph>
                                    </list_item>
                                </bullet_list>
                            </field_body>
                        </field>
                    </field_list>
                </desc_content>
            </desc>
        </section>
    </section>
</document>
